var l=Object.defineProperty;var f=(e,t,n)=>t in e?l(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n;var y=(e,t,n)=>(f(e,typeof t!="symbol"?t+"":t,n),n);var i=function(e,t,n=!1){if(!t&&!n)throw new TypeError("Type is not defined");if(e?.constructor){if(e.constructor!=t)throw new TypeError(`Value is not type ${t.name}`)}else if(!n)throw new TypeError("Value is not nullable")};var o=function(e){let t;switch(e?.constructor){case Uint8Array:{t=e;break}case Int8Array:case Uint8ClampedArray:case Int16Array:case Uint16Array:case Int32Array:case Uint32Array:case Float32Array:case BigInt64Array:case BigUint64Array:case Float64Array:t=new Uint8Array(e.buffer,e.buffer.byteOffset,e.buffer.byteLength);default:throw new TypeError("Unaccepted type for conversion")}return t};var d=function(e,t=1,n,r=1,c){i(e,Uint8Array),i(n,Uint8Array),i(t,Number),i(r,Number);for(let h=0,a=0;h<e.length;h+=t,a+=r)c(e.subarray(h,h+t),n.subarray(a,a+r))},s,E=(s=class{static encodeLength(e){return i(e,Number),Math.ceil(e*this.chunkSizeDec/this.chunkSizeEnc)}static decodeLength(e){return i(e,Number),Math.floor(e*this.chunkSizeEnc/this.chunkSizeDec)}static encodeBlock(e,t){i(e,Uint8Array),i(t,Uint8Array);let n=this.encodeLength(e.length);if(e.length>this.chunkSizeEnc)throw new Error(`Source (${e.length}) is greater than ${this.chunkSizeEnc} bytes`);if(t.length<n)throw new Error(`Target (${t.length}) isn't sufficient for encoding`);n=BigInt(n);let r=0n;e.forEach((c,h)=>{r|=BigInt(c)<<(BigInt(h)<<3n)});for(let c=0n;c<n;c++)t[c]=Number(r%95n+32n),r/=95n}static decodeBlock(e,t){i(e,Uint8Array),i(t,Uint8Array);let n=this.decodeLength(e.length);if(e.length>this.chunkSizeDec)throw new Error(`Source (${e.length}) is greater than ${this.chunkSizeEnc} bytes`);if(t.length<n)throw new Error(`Target (${t.length}) isn't sufficient for decoding`);n=BigInt(n);let r=0n;e.forEach((c,h)=>{r+=(BigInt(c)-32n)*95n**BigInt(h)});for(let c=0n;c<n;c++)t[c]=Number(r&255n),r=r>>8n}static encodeBytes(e,t){if(i(e,Uint8Array),i(t,Uint8Array),t.length<this.encodeLength(e.length))throw new Error("Target isn't sufficient for encoding");d(e,this.chunkSizeEnc,t,this.chunkSizeDec,(n,r)=>{this.encodeBlock(n,r)})}static decodeBytes(e,t){if(i(e,Uint8Array),i(t,Uint8Array),t.length<this.decodeLength(e.length))throw new Error("Target isn't sufficient for decoding");d(e,this.chunkSizeDec,t,this.chunkSizeEnc,(n,r)=>{this.decodeBlock(n,r)})}static encodeSync(e,t){this.encodeBytes(o(e),o(t))}static decodeSync(e,t){this.decodeBytes(o(e),o(t))}static async encode(e,t){this.encodeBytes(o(e),o(t))}static async decode(e,t){this.decodeBytes(o(e),o(t))}},y(s,"chunkSizeEnc",9),y(s,"chunkSizeDec",11),s);export{E as Block95};
